package org.yeastrc.proxl.xml.byonic.reader;

import info.psidev.psi.pi.mzidentml._1.*;
import org.yeastrc.proxl.xml.byonic.constants.SearchConstants;
import org.yeastrc.proxl.xml.byonic.linkers.ByonicLinker;
import org.yeastrc.proxl.xml.byonic.linkers.ByonicLinkerFactory;
import org.yeastrc.proxl.xml.byonic.objects.*;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import java.io.File;
import java.math.BigDecimal;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ByonicResultsParser {

    public static ByonicResults getByonicResults(File mzidFile) throws Exception {

        ByonicResults byonicResults = new ByonicResults();

        MzIdentMLType mzIdentML = getMzIdentML(mzidFile);

        // confirm data were generated by Byonic
        String softwareName = mzIdentML.getAnalysisSoftwareList().getAnalysisSoftware().get(0).getName();
        if(!softwareName.equals("Byonic")) {
            throw new Exception("Expected software name to be \"Byonic\", but got \"" + softwareName + "\"");
        }

        String version = mzIdentML.getAnalysisSoftwareList().getAnalysisSoftware().get(0).getVersion();
        System.err.println("\tByonic version: " + version);

        System.err.print("\tReading proteins... ");
        Map<Integer, ByonicProtein> proteinIndexMap = getProteinIndexMap(mzIdentML);
        System.err.println("Found " + proteinIndexMap.size() + " proteins.");

        // the cross-linkers found while parsing peptides, indexed by peptide id in the mzID file
        Map<String, ByonicLinker> peptideLinkerMap = new HashMap<>();

        // the cross-linker masses found while parsing peptides, indexed by peptide id in the mzID file
        Map<String, BigDecimal> peptideLinkerMassMap = new HashMap<>();

        // all reported peptides indexed by internal peptide id
        System.err.print("\tReading peptides... ");
        Map<String, ByonicReportedPeptide> peptideIdMap = getPeptides(mzIdentML, peptideLinkerMap, peptideLinkerMassMap);
        System.err.println("Found " + peptideIdMap.size() + " peptides.");

        // all peptideevidenceref entries, indexed by pepvideevidence id
        Map<String, PeptideEvidence> peptideEvidenceMap = getPeptideEvidence(mzIdentML);

        // all psms indexed by ByonicReportedPeptide
        System.err.print("\tReading PSMs... ");
        Map<ByonicReportedPeptide, Collection<ByonicPSM>> psmPeptideMap = getPsms(mzIdentML, peptideIdMap, peptideLinkerMap, peptideLinkerMassMap, peptideEvidenceMap);
        System.err.println("Done.");

        // all distinct linkers found
        Collection<ByonicLinker> linkers = new HashSet<>();
        linkers.addAll(peptideLinkerMap.values());

        byonicResults.setByonicVersion(version);
        byonicResults.setFastaFile(getFastaFile(mzIdentML));
        byonicResults.setLinkers(linkers);
        byonicResults.setProteins(proteinIndexMap.values());
        byonicResults.setPeptidePsmMap(psmPeptideMap);

        return byonicResults;
    }

    /**
     * Get the FASTA file name from the mzID JaxB object
     * @param mzIdentML
     * @return
     */
    private static String getFastaFile(MzIdentMLType mzIdentML) {
        try {
            for (AbstractParamType userParam : mzIdentML.getAnalysisProtocolCollection().getSpectrumIdentificationProtocol().get(0).getAdditionalSearchParams().getParamGroup()) {
                if(userParam.getName().equals("Protein database")) {
                    return (new File(userParam.getValue())).getName();
                }
            }
        } catch(Exception e) {
            return "Not found (e)";
        }

        return "Not found";
    }

    private static Map<ByonicReportedPeptide, Collection<ByonicPSM>> getPsms(
            MzIdentMLType mzIdentML,
            Map<String,ByonicReportedPeptide> peptideIdMap,
            Map<String, ByonicLinker> peptideLinkerMap,
            Map<String, BigDecimal> peptideLinkerMassMap,
            Map<String, PeptideEvidence> peptideEvidenceMap
    ) throws Exception {

        Map<ByonicReportedPeptide, Collection<ByonicPSM>> psmPeptideMap = new HashMap<>();

        for(SpectrumIdentificationResultType result : mzIdentML.getDataCollection().getAnalysisData().getSpectrumIdentificationList().get(0).getSpectrumIdentificationResult()) {
            String spectrumId = result.getSpectrumID();
            int scanNumber = Integer.parseInt(spectrumId.split("=")[1]);    // this is formatted as "index=96"
            scanNumber += 1;    // scan number is almost always 1-indexed as opposed to 0-indexed

            for(SpectrumIdentificationItemType byonicPsm : result.getSpectrumIdentificationItem()) {


                String peptideId = byonicPsm.getPeptideRef();
                if(!(peptideIdMap.containsKey(peptideId))) {
                    throw new Exception("Could not find peptide with peptide id: " + peptideId);
                }

                ByonicReportedPeptide reportedPeptide = peptideIdMap.get(byonicPsm.getPeptideRef());

                int charge = byonicPsm.getChargeState();
                BigDecimal obsMz = BigDecimal.valueOf(byonicPsm.getExperimentalMassToCharge());

                BigDecimal score = null;
                BigDecimal deltaScore = null;
                BigDecimal deltaModScore = null;
                BigDecimal absLogProb2D = null;

                for( AbstractParamType cv : byonicPsm.getParamGroup()) {
                    String name = cv.getName();
                    if (name.equals("Byonic:Score")) {
                        score = new BigDecimal(cv.getValue());
                    } else if (name.equals("Byonic:Delta Score")) {
                        deltaScore = new BigDecimal(cv.getValue());
                    } else if (name.equals("Byonic:DeltaMod Score")) {
                        deltaModScore = new BigDecimal(cv.getValue());
                    } else if (name.equals("Byonic: Peptide AbsLogProb2D")) {
                        absLogProb2D = new BigDecimal(cv.getValue());
                    }
                }

                ByonicPSMBuilder psmBuilder = new ByonicPSMBuilder();
                psmBuilder.setScore(score);
                psmBuilder.setCharge(charge);
                psmBuilder.setAbsLogProb2D(absLogProb2D);
                psmBuilder.setDeltaModScore(deltaModScore);
                psmBuilder.setDeltaScore(deltaScore);
                psmBuilder.setObsMz(obsMz);
                psmBuilder.setScanNumber(scanNumber);

                if(reportedPeptide.getType() == SearchConstants.LINK_TYPE_CROSSLINK) {
                    if(!(peptideLinkerMap.containsKey(peptideId))) {
                        throw new Exception("Could not find linker for peptide id: " + peptideId);
                    }

                    if(!(peptideLinkerMassMap.containsKey(peptideId))) {
                        throw new Exception("Could not find linker mass for peptide id: " + peptideId);
                    }

                    psmBuilder.setLinkerMass(peptideLinkerMassMap.get(peptideId));
                }

                if(!(psmPeptideMap.containsKey(reportedPeptide))) {
                    psmPeptideMap.put(reportedPeptide, new HashSet<>());
                }

                psmPeptideMap.get(reportedPeptide).add(psmBuilder.createByonicPSM());
            }

        }


        return psmPeptideMap;
    }

    private static Map<String, PeptideEvidence> getPeptideEvidence(MzIdentMLType mzIdentML) {
        Map<String, PeptideEvidence> peptideEvidenceMap = new HashMap<>();

        for(PeptideEvidenceType peptideEvidence : mzIdentML.getSequenceCollection().getPeptideEvidence()) {
            peptideEvidenceMap.put(peptideEvidence.getId(), new PeptideEvidence(
                    peptideEvidence.getPeptideRef(),
                    peptideEvidence.getDBSequenceRef(),
                    peptideEvidence.getStart(),
                    peptideEvidence.getEnd(),
                    peptideEvidence.getPre(),
                    peptideEvidence.getPost(),
                    peptideEvidence.isIsDecoy()
            ));
        }

        return peptideEvidenceMap;
    }

    private static Map<String, ByonicReportedPeptide> getPeptides(MzIdentMLType mzIdentML, Map<String, ByonicLinker> peptideLinkerMap, Map<String, BigDecimal> peptideLinkerMassMap) throws Exception {

        Map<String, ByonicReportedPeptide> peptideIdMap = new HashMap<>();

        for(PeptideType peptideType : mzIdentML.getSequenceCollection().getPeptide()) {
            String id = peptideType.getId();

            String nakedSequence1 = peptideType.getPeptideSequence();
            Map<Integer, Collection<BigDecimal>> variableMods = getVariableModsForPeptide(peptideType);

            ByonicPeptideBuilder peptideBuilder = new ByonicPeptideBuilder();
            peptideBuilder.setSequence(nakedSequence1);
            if(variableMods != null && variableMods.size() > 0) {
                peptideBuilder.setModifications(variableMods);
            }


            ByonicReportedPeptide reportedPeptide = null;

            if (peptideIsCrosslink(peptideType)) {
                // handle cross-linked peptide

                ByonicLinkedPosition byonicLinkedPosition = getLinkedPositionForPeptideType(peptideType);
                int position1 = byonicLinkedPosition.getPosition();

                ByonicLinker linker = byonicLinkedPosition.getLinker();
                peptideLinkerMap.put(id, linker);
                peptideLinkerMassMap.put(id, getLinkDeltaMass(peptideType));

                ByonicPeptide peptide1 = new ByonicPeptide(peptideBuilder);

                String sequence2 = getPeptide2Sequence(peptideType);
                int position2 = getPeptide2Position(peptideType);

                peptideBuilder.setSequence(sequence2);
                peptideBuilder.setModifications(null);

                ByonicPeptide peptide2 = new ByonicPeptide(peptideBuilder);

                ByonicReportedPeptideBuilder brrb = new ByonicReportedPeptideBuilder();
                brrb.setType(SearchConstants.LINK_TYPE_CROSSLINK);

                brrb.setPeptide1(peptide1);
                brrb.setPosition1(position1);
                brrb.setPeptide2(peptide2);
                brrb.setPosition2(position2);

                reportedPeptide = new ByonicReportedPeptide(brrb);

            } else {
                // handle non-cross-linked peptide

                ByonicReportedPeptideBuilder brrb = new ByonicReportedPeptideBuilder();
                brrb.setPeptide1(new ByonicPeptide(peptideBuilder));
                brrb.setType(SearchConstants.LINK_TYPE_UNLINKED);

                reportedPeptide = new ByonicReportedPeptide(brrb);
            }

            peptideIdMap.put(id, reportedPeptide);

        }

        return peptideIdMap;
    }

    private static int getPeptide2Position(PeptideType peptideType) throws Exception {
        Pattern p = Pattern.compile("^.+ Position:(\\d+) LinkPosition:(\\d+) .+$");
        Pattern p2 = Pattern.compile("^.+ Position:(\\d+) LinkPosition:(\\d+),(\\d+) .+$");

        for(ModificationType modificationType : peptideType.getModification()) {
            for(CVParamType cvParamType : modificationType.getCvParam()) {
                String value = cvParamType.getValue();
                if(value.startsWith("{xlink-inter}")) {
                    Matcher m = p.matcher(value);

                    if(m.matches()) {
                        int peptidePosition = Integer.parseInt(m.group(1));
                        int proteinLinkPosition = Integer.parseInt(m.group(2));

                        return proteinLinkPosition - peptidePosition + 1;
                    }

                    m = p2.matcher(value);

                    if(m.matches()) {
                        int peptidePosition = Integer.parseInt(m.group(1));
                        int proteinLinkPosition = Integer.parseInt(m.group(2));

                        return proteinLinkPosition - peptidePosition + 1;
                    }

                    throw new Exception("Could not find linked position in: " + value);
                }
            }
        }

        throw new Exception("Couldn't find linker in reportedly linked peptide.");
    }

    private static BigDecimal getLinkDeltaMass(PeptideType peptideType) throws Exception {
        Pattern p = Pattern.compile("^.+ LinkDeltaMass:([+-]?([\\d]+\\.?[\\d]*|\\.[\\d]+)) .+$");

        for(ModificationType modificationType : peptideType.getModification()) {
            for(CVParamType cvParamType : modificationType.getCvParam()) {
                String value = cvParamType.getValue();
                if(value.startsWith("{xlink-inter}")) {
                    Matcher m = p.matcher(value);

                    if(!m.matches()) {
                        throw new Exception("Could not parse reported cross-linked peptide: " + value);
                    }

                    return new BigDecimal(m.group(1));
                }
            }
        }

        throw new Exception("Couldn't find linker in reportedly linked peptide.");
    }

    private static String getPeptide2Sequence(PeptideType peptideType) throws Exception {
        Pattern p = Pattern.compile("^.+ Seq:[\\w\\-]\\.(\\w+)\\.[\\w\\-] .+$");

        for(ModificationType modificationType : peptideType.getModification()) {
            for(CVParamType cvParamType : modificationType.getCvParam()) {
                String value = cvParamType.getValue();
                if(value.startsWith("{xlink-inter}")) {
                    Matcher m = p.matcher(value);

                    if(!m.matches()) {
                        throw new Exception("Could not parse reported cross-linked peptide: " + value);
                    }

                    return m.group(1);
                }
            }
        }

        throw new Exception("Couldn't find linker in reportedly linked peptide.");
    }

    private static ByonicLinkedPosition getLinkedPositionForPeptideType(PeptideType peptideType) throws Exception {

        Pattern p = Pattern.compile("^.+ LinkName:\\{(.+)\\} .+$");

        for(ModificationType modificationType : peptideType.getModification()) {
            for(CVParamType cvParamType : modificationType.getCvParam()) {
                String value = cvParamType.getValue();
                if(value.startsWith("{xlink-inter}")) {
                    Matcher m = p.matcher(value);

                    if(!m.matches()) {
                        throw new Exception("Could not parse reported cross-linked peptide: " + value);
                    }

                    String linkerName = m.group(1);
                    ByonicLinker linker = ByonicLinkerFactory.getLinker(linkerName);

                    if(linker == null) {
                        throw new Exception("Could not find definition for linker:" + linkerName);
                    }

                    return new ByonicLinkedPosition(modificationType.getLocation(), linker);
                }
            }
        }

        throw new Exception("Couldn't find linker in reportedly linked peptide.");
    }


    /**
     * Whether the PeptideType has any modifications reported
     *
     * @param peptideType
     * @return
     */
    private static boolean peptideHasModTypes(PeptideType peptideType) {
        return peptideType.getModification() != null && peptideType.getModification().size() > 0;
    }



    /**
     * Whether the PeptideType contains any variable mods
     * @param peptideType
     * @return
     */
    private static Map<Integer, Collection<BigDecimal>> getVariableModsForPeptide(PeptideType peptideType) {

        Map<Integer, Collection<BigDecimal>> modPositionMap = new HashMap<>();

        if(!peptideHasModTypes(peptideType)) { return modPositionMap; }

        for(ModificationType modificationType : peptideType.getModification()) {
            for(CVParamType cvParamType : modificationType.getCvParam()) {
                String value = cvParamType.getValue();
                if(!(value.startsWith("{xlink-inter}"))) {
                    modPositionMap.put(
                            modificationType.getLocation(),
                            new HashSet<>()
                    );

                    modPositionMap.get(modificationType.getLocation()).add(
                            BigDecimal.valueOf(modificationType.getMonoisotopicMassDelta())
                    );
                }
            }
        }

        return modPositionMap;
    }

    /**
     * Whether the PeptideType contains any cross-links
     * @param peptideType
     * @return
     */
    private static boolean peptideIsCrosslink(PeptideType peptideType) {
        if(!peptideHasModTypes(peptideType)) { return false; }

        for(ModificationType modificationType : peptideType.getModification()) {
            for(CVParamType cvParamType : modificationType.getCvParam()) {
                String value = cvParamType.getValue();
                if(value.startsWith("{xlink-inter}")) {
                    return true;
                }
            }
        }

        return false;
    }


    /**
     * Byonic cross-link results at the peptide-level, for some reason, report that result as a
     * position in the first peptide to a position in the _protein_ for the second peptide. So, in
     * order to figure out what the position of the link is in the second peptide, the peptide
     * has to be mapped to the protein sequence then the position in the peptide calculated... This
     * 2nd protein is reported using the index of that protein. This will build the lookup map
     * necessary for quickly getting the protein sequence of these protein indices.
     *
     * @param mzIdentML The mzIdentML JAXB object
     * @return The map of protein indices to ByonicProtein objects
     */
    private static Map<Integer, ByonicProtein> getProteinIndexMap(MzIdentMLType mzIdentML) throws Exception {

        Map<Integer, ByonicProtein> proteinIndexMap = new HashMap<>();

        Pattern p = Pattern.compile("^DBSEQ_(\\d+)$");

        for(DBSequenceType dbSequenceType : mzIdentML.getSequenceCollection().getDBSequence()) {
            ByonicProtein byonicProtein = new ByonicProtein(
                    dbSequenceType.getSeq(),
                    dbSequenceType.getId(),
                    dbSequenceType.getAccession(),
                    dbSequenceType.getSearchDatabaseRef()
            );

            Matcher m = p.matcher(byonicProtein.getId());
            if(!m.matches()) {
                throw new Exception("Could not get protein index from id: " + byonicProtein.getId());
            }

            int index = Integer.parseInt(m.group(1));
            if(proteinIndexMap.containsKey(index)) {
                throw new Exception("Got more than 1 protein with index of " + index);
            }

            proteinIndexMap.put(index, byonicProtein);
        }

        return proteinIndexMap;
    }

    private static MzIdentMLType getMzIdentML(File mzidFile) throws JAXBException {

        MzIdentMLType mzIdentML = null;

        try {
            JAXBContext jaxbContext = JAXBContext.newInstance(MzIdentMLType.class);
            Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
            mzIdentML = (MzIdentMLType)jaxbUnmarshaller.unmarshal( mzidFile );
        } catch (JAXBException e) {
            System.err.println("Error processing mzIdentML file: " + mzidFile.getAbsolutePath());
            throw e;
        }

        return mzIdentML;
    }

}
